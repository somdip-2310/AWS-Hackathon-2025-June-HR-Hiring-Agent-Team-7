name: Deploy HR Demo to ECS (Zero Downtime)

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
    types: [ closed ]

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: somdip-hr-demo
  ECS_SERVICE: somdip-hr-demo-service
  ECS_CLUSTER: somdip-dev-cluster
  ECS_TASK_DEFINITION: somdip-hr-demo
  CONTAINER_NAME: hr-demo
  LOG_GROUP: /ecs/somdip-hr-demo

jobs:
  deploy:
    name: Deploy to ECS with Zero Downtime
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.pull_request.merged == true)

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Set up JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'

    - name: Cache Maven dependencies
      uses: actions/cache@v3
      with:
        path: ~/.m2
        key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
        restore-keys: ${{ runner.os }}-m2

    - name: Run tests
      run: mvn clean test

    - name: Build with Maven
      run: mvn clean package -DskipTests

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build, tag, and push image to Amazon ECR
      id: build-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        echo "üèóÔ∏è Building Docker image..."
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
        
        echo "üì§ Pushing image to ECR..."
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
        
        echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT
        echo "‚úÖ Image pushed successfully"

    - name: Get current task definition
      id: current-task-def
      run: |
        echo "üìã Fetching current task definition..."
        
        # Get the current task definition
        aws ecs describe-task-definition \
          --task-definition $ECS_TASK_DEFINITION \
          --query 'taskDefinition' > current-task-def.json
        
        # Extract important values
        CURRENT_CPU=$(cat current-task-def.json | jq -r '.cpu')
        CURRENT_MEMORY=$(cat current-task-def.json | jq -r '.memory')
        EXECUTION_ROLE=$(cat current-task-def.json | jq -r '.executionRoleArn')
        TASK_ROLE=$(cat current-task-def.json | jq -r '.taskRoleArn')
        
        echo "current-cpu=$CURRENT_CPU" >> $GITHUB_OUTPUT
        echo "current-memory=$CURRENT_MEMORY" >> $GITHUB_OUTPUT
        echo "execution-role=$EXECUTION_ROLE" >> $GITHUB_OUTPUT
        echo "task-role=$TASK_ROLE" >> $GITHUB_OUTPUT
        
        echo "‚úÖ Current configuration retrieved"

    - name: Create optimized task definition
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
        EXECUTION_ROLE: ${{ steps.current-task-def.outputs.execution-role }}
        TASK_ROLE: ${{ steps.current-task-def.outputs.task-role }}
      run: |
        echo "üìù Creating optimized task definition for zero downtime..."
        
        # Create task definition with all current settings preserved
        cat > task-definition.json << EOF
        {
          "family": "$ECS_TASK_DEFINITION",
          "networkMode": "awsvpc",
          "requiresCompatibilities": ["FARGATE"],
          "cpu": "256",
          "memory": "512",
          "executionRoleArn": "$EXECUTION_ROLE",
          "taskRoleArn": "$TASK_ROLE",
          "containerDefinitions": [
            {
              "name": "$CONTAINER_NAME",
              "image": "$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG",
              "cpu": 256,
              "memory": 512,
              "essential": true,
              "portMappings": [
                {
                  "containerPort": 8081,
                  "protocol": "tcp"
                }
              ],
              "environment": [
                {"name": "SERVER_PORT", "value": "8081"},
                {"name": "SPRING_PROFILES_ACTIVE", "value": "prod"},
                {"name": "AWS_REGION", "value": "$AWS_REGION"},
                {"name": "JAVA_OPTS", "value": "-XX:MaxRAMPercentage=75.0 -XX:+UseG1GC"}
              ],
              "logConfiguration": {
                "logDriver": "awslogs",
                "options": {
                  "awslogs-group": "$LOG_GROUP",
                  "awslogs-region": "$AWS_REGION",
                  "awslogs-stream-prefix": "ecs"
                }
              },
              "healthCheck": {
                "command": ["CMD-SHELL", "curl -f http://localhost:8081/ || exit 1"],
                "interval": 30,
                "timeout": 5,
                "retries": 3,
                "startPeriod": 60
              }
            }
          ]
        }
        EOF
        
        echo "‚úÖ Task definition created"

    - name: Register new task definition
      id: register-task-def
      run: |
        echo "üìù Registering new task definition..."
        
        NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
          --cli-input-json file://task-definition.json \
          --query 'taskDefinition.taskDefinitionArn' \
          --output text)
        
        echo "new-task-def-arn=$NEW_TASK_DEF_ARN" >> $GITHUB_OUTPUT
        REVISION=$(echo $NEW_TASK_DEF_ARN | awk -F: '{print $NF}')
        echo "‚úÖ New task definition registered: Revision $REVISION"

    - name: Update service for zero-downtime deployment
      run: |
        echo "üöÄ Starting zero-downtime deployment..."
        
        # Get current service configuration
        CURRENT_COUNT=$(aws ecs describe-services \
          --cluster $ECS_CLUSTER \
          --service $ECS_SERVICE \
          --query 'services[0].desiredCount' \
          --output text)
        
        echo "üìä Current desired count: $CURRENT_COUNT"
        
        # Update service with rolling deployment (REMOVED placement-strategy)
        aws ecs update-service \
          --cluster $ECS_CLUSTER \
          --service $ECS_SERVICE \
          --task-definition ${{ steps.register-task-def.outputs.new-task-def-arn }} \
          --desired-count $CURRENT_COUNT \
          --health-check-grace-period-seconds 120 \
          --force-new-deployment \
          --deployment-configuration '{
            "deploymentCircuitBreaker": {
              "enable": true,
              "rollback": true
            },
            "maximumPercent": 200,
            "minimumHealthyPercent": 100
          }' \
          --query 'service.[serviceName,taskDefinition]' \
          --output table
        
        echo "‚úÖ Zero-downtime deployment initiated"
        echo "üìå Strategy: Rolling update with 100% minimum healthy"
        echo "üìå Fargate will automatically distribute tasks across AZs"

    - name: Monitor zero-downtime deployment
      run: |
        echo "üëÄ Monitoring zero-downtime deployment progress..."
        
        START_TIME=$(date +%s)
        TIMEOUT=600  # 10 minutes
        
        while true; do
          # Get deployment status
          DEPLOYMENT_INFO=$(aws ecs describe-services \
            --cluster $ECS_CLUSTER \
            --service $ECS_SERVICE \
            --query 'services[0].deployments' \
            --output json)
          
          # Count deployments
          DEPLOYMENT_COUNT=$(echo $DEPLOYMENT_INFO | jq 'length')
          
          if [ "$DEPLOYMENT_COUNT" -eq 1 ]; then
            # Only one deployment means the new one is now primary
            PRIMARY_STATUS=$(echo $DEPLOYMENT_INFO | jq -r '.[0].status')
            if [ "$PRIMARY_STATUS" = "PRIMARY" ]; then
              echo "‚úÖ Deployment completed successfully!"
              break
            fi
          fi
          
          # Show current status
          echo "üìä Deployment status at $(date '+%H:%M:%S'):"
          echo $DEPLOYMENT_INFO | jq -r '.[] | "  - \(.status): \(.desiredCount) desired, \(.runningCount) running, \(.pendingCount) pending"'
          
          # Check timeout
          CURRENT_TIME=$(date +%s)
          ELAPSED=$((CURRENT_TIME - START_TIME))
          if [ $ELAPSED -gt $TIMEOUT ]; then
            echo "‚ùå Deployment timeout after $TIMEOUT seconds"
            exit 1
          fi
          
          # Check for failed tasks
          FAILED_TASKS=$(echo $DEPLOYMENT_INFO | jq '[.[] | select(.failedTasks > 0)] | length')
          if [ "$FAILED_TASKS" -gt 0 ]; then
            echo "‚ùå Deployment has failed tasks"
            aws ecs describe-services --cluster $ECS_CLUSTER --service $ECS_SERVICE --query 'services[0].events[:5]' --output table
            exit 1
          fi
          
          sleep 20
        done

    - name: Verify healthy deployment
      run: |
        echo "üè• Verifying deployment health..."
        
        # Wait for tasks to stabilize
        sleep 30
        
        # Get running tasks
        TASK_ARNS=$(aws ecs list-tasks \
          --cluster $ECS_CLUSTER \
          --service-name $ECS_SERVICE \
          --desired-status RUNNING \
          --query 'taskArns' \
          --output text)
        
        if [ -z "$TASK_ARNS" ]; then
          echo "‚ùå No running tasks found"
          exit 1
        fi
        
        # Check all tasks are healthy
        TASK_COUNT=$(echo $TASK_ARNS | wc -w)
        echo "‚úÖ Found $TASK_COUNT running tasks"
        
        # Verify tasks are using new image
        NEW_IMAGE_COUNT=0
        for TASK in $TASK_ARNS; do
          IMAGE=$(aws ecs describe-tasks \
            --cluster $ECS_CLUSTER \
            --tasks $TASK \
            --query 'tasks[0].containers[0].image' \
            --output text)
          
          if [[ "$IMAGE" == *"${{ github.sha }}"* ]]; then
            ((NEW_IMAGE_COUNT++))
          fi
        done
        
        echo "‚úÖ $NEW_IMAGE_COUNT/$TASK_COUNT tasks running new image"
        
        if [ "$NEW_IMAGE_COUNT" -ne "$TASK_COUNT" ]; then
          echo "‚ö†Ô∏è Not all tasks updated yet"
        fi
        
        # Check task distribution across AZs
        echo "üìç Task distribution:"
        aws ecs describe-tasks \
          --cluster $ECS_CLUSTER \
          --tasks $TASK_ARNS \
          --query 'tasks[*].[taskArn,availabilityZone]' \
          --output table

    - name: Verify ALB target health
      run: |
        echo "üéØ Checking ALB target health..."
        
        # Get target group ARN
        TG_ARN=$(aws elbv2 describe-target-groups \
          --names somdip-dev-hr-demo \
          --query 'TargetGroups[0].TargetGroupArn' \
          --output text 2>/dev/null || echo "")
        
        if [ ! -z "$TG_ARN" ] && [ "$TG_ARN" != "None" ]; then
          # Check target health
          HEALTHY_COUNT=$(aws elbv2 describe-target-health \
            --target-group-arn $TG_ARN \
            --query 'length(TargetHealthDescriptions[?TargetHealth.State==`healthy`])' \
            --output text)
          
          TOTAL_COUNT=$(aws elbv2 describe-target-health \
            --target-group-arn $TG_ARN \
            --query 'length(TargetHealthDescriptions)' \
            --output text)
          
          echo "‚úÖ Healthy targets: $HEALTHY_COUNT/$TOTAL_COUNT"
          
          # Show target details
          aws elbv2 describe-target-health \
            --target-group-arn $TG_ARN \
            --query 'TargetHealthDescriptions[*].[Target.Id,TargetHealth.State,Target.AvailabilityZone]' \
            --output table
        fi

    - name: Test application endpoints
      run: |
        echo "üß™ Testing application endpoints..."
        
        # Test ALB health
        ALB_DNS="somdip-dev-alb-856223136.us-east-1.elb.amazonaws.com"
        
        # Test with retries
        MAX_RETRIES=5
        RETRY_COUNT=0
        
        while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" -H "Host: demos.somdip.dev" http://$ALB_DNS:8081 || echo "000")
          HTTPS_STATUS=$(curl -s -o /dev/null -w "%{http_code}" https://demos.somdip.dev || echo "000")
          
          if [ "$HTTP_STATUS" = "200" ] || [ "$HTTPS_STATUS" = "200" ]; then
            echo "‚úÖ Application is healthy!"
            echo "  - HTTP Status: $HTTP_STATUS"
            echo "  - HTTPS Status: $HTTPS_STATUS"
            
            # Test a few endpoints
            echo ""
            echo "Testing specific endpoints:"
            curl -s -o /dev/null -w "  - Root endpoint: %{http_code}\n" https://demos.somdip.dev/
            curl -s -o /dev/null -w "  - API endpoint: %{http_code}\n" https://demos.somdip.dev/api/jobs
            break
          else
            echo "‚ö†Ô∏è Retry $((RETRY_COUNT + 1))/$MAX_RETRIES - HTTP: $HTTP_STATUS, HTTPS: $HTTPS_STATUS"
            ((RETRY_COUNT++))
            sleep 10
          fi
        done

    - name: Deployment summary
      run: |
        echo ""
        echo "üéâ HR Demo Zero-Downtime Deployment Complete!"
        echo "============================================="
        echo "‚úÖ Image: ${{ steps.build-image.outputs.image }}"
        echo "‚úÖ Task Definition: ${{ steps.register-task-def.outputs.new-task-def-arn }}"
        echo "‚úÖ Deployment Strategy: Rolling update (100% minimum healthy)"
        echo ""
        echo "üìä Service Status:"
        aws ecs describe-services \
          --cluster $ECS_CLUSTER \
          --service $ECS_SERVICE \
          --query 'services[0].[serviceName,runningCount,desiredCount,pendingCount]' \
          --output table
        echo ""
        echo "üîó Application URLs:"
        echo "   Production: https://demos.somdip.dev"
        echo "   Health Check: https://demos.somdip.dev/"
        echo "   API Base: https://demos.somdip.dev/api"
        echo ""
        echo "üìù Zero-Downtime Features:"
        echo "   ‚úì Rolling deployment with 100% minimum healthy"
        echo "   ‚úì Circuit breaker with automatic rollback"
        echo "   ‚úì Automatic multi-AZ distribution (Fargate)"
        echo "   ‚úì Health check grace period (120s)"
        echo "   ‚úì No service interruption"
        echo ""
        echo "üí° Note: Fargate automatically distributes tasks across AZs"

    - name: Cleanup
      run: |
        rm -f task-definition.json current-task-def.json
        echo "‚úÖ Cleanup completed"
