name: Deploy HR Demo to ECS (Zero Downtime)

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
    types: [ closed ]

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: somdip-hr-demo
  ECS_SERVICE: somdip-hr-demo-service
  ECS_CLUSTER: somdip-dev-cluster
  ECS_TASK_DEFINITION: somdip-hr-demo
  CONTAINER_NAME: hr-demo
  LOG_GROUP: /ecs/somdip-hr-demo

jobs:
  deploy:
    name: Deploy to ECS with Zero Downtime
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.pull_request.merged == true)

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Set up JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'

    - name: Cache Maven dependencies
      uses: actions/cache@v3
      with:
        path: ~/.m2
        key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
        restore-keys: ${{ runner.os }}-m2

    - name: Run tests
      run: mvn clean test

    - name: Build with Maven
      run: mvn clean package -DskipTests

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build, tag, and push image to Amazon ECR
      id: build-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        echo "üèóÔ∏è Building Docker image..."
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
        
        echo "üì§ Pushing image to ECR..."
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
        
        echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT
        echo "‚úÖ Image pushed successfully"

    - name: Ensure CloudWatch Log Groups Exist
      run: |
        echo "üìã Ensuring CloudWatch log groups exist..."
        
        # Create both possible log group names
        for LOG_GROUP_NAME in "/ecs/somdip-hr-demo" "/ecs/hr-demo"; do
          aws logs create-log-group --log-group-name $LOG_GROUP_NAME --region $AWS_REGION 2>/dev/null || echo "Log group $LOG_GROUP_NAME already exists"
          aws logs put-retention-policy --log-group-name $LOG_GROUP_NAME --retention-in-days 7 --region $AWS_REGION 2>/dev/null || true
        done
        
        echo "‚úÖ Log groups ready"

    - name: Update ALB Target Group Health Check Settings
      run: |
        echo "üè• Configuring health checks for zero downtime..."
        
        # Get target group ARN
        TG_ARN=$(aws elbv2 describe-target-groups \
          --names somdip-dev-hr-demo \
          --query 'TargetGroups[0].TargetGroupArn' \
          --output text 2>/dev/null || echo "")
        
        if [ ! -z "$TG_ARN" ] && [ "$TG_ARN" != "None" ]; then
          # Make health checks more lenient for zero downtime
          aws elbv2 modify-target-group \
            --target-group-arn $TG_ARN \
            --health-check-interval-seconds 30 \
            --health-check-timeout-seconds 10 \
            --unhealthy-threshold-count 5 \
            --healthy-threshold-count 2 \
            --matcher HttpCode=200,404 || echo "Failed to update health check"
          
          echo "‚úÖ Health check settings optimized"
        fi

    - name: Get current task definition and validate
      id: current-task-def
      run: |
        echo "üìã Getting current task definition..."
        
        # Get current task definition
        aws ecs describe-task-definition \
          --task-definition $ECS_TASK_DEFINITION \
          --query 'taskDefinition' > current-task-def.json
        
        # Extract values
        EXECUTION_ROLE=$(cat current-task-def.json | jq -r '.executionRoleArn')
        TASK_ROLE=$(cat current-task-def.json | jq -r '.taskRoleArn // .executionRoleArn')
        
        echo "execution-role=$EXECUTION_ROLE" >> $GITHUB_OUTPUT
        echo "task-role=$TASK_ROLE" >> $GITHUB_OUTPUT
        
        # Validate roles exist
        aws iam get-role --role-name $(basename $EXECUTION_ROLE) > /dev/null 2>&1 || {
          echo "‚ùå Execution role not found: $EXECUTION_ROLE"
          exit 1
        }
        
        echo "‚úÖ Current configuration validated"

    - name: Create fail-safe task definition
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
        EXECUTION_ROLE: ${{ steps.current-task-def.outputs.execution-role }}
        TASK_ROLE: ${{ steps.current-task-def.outputs.task-role }}
      run: |
        echo "üìù Creating fail-safe task definition..."
        
        # Create task definition with increased memory for stability
        cat > task-definition.json << EOF
        {
          "family": "$ECS_TASK_DEFINITION",
          "networkMode": "awsvpc",
          "requiresCompatibilities": ["FARGATE"],
          "cpu": "512",
          "memory": "1024",
          "executionRoleArn": "$EXECUTION_ROLE",
          "taskRoleArn": "$TASK_ROLE",
          "containerDefinitions": [
            {
              "name": "$CONTAINER_NAME",
              "image": "$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG",
              "cpu": 512,
              "memory": 1024,
              "essential": true,
              "portMappings": [
                {
                  "containerPort": 8081,
                  "protocol": "tcp"
                }
              ],
              "environment": [
                {"name": "SERVER_PORT", "value": "8081"},
                {"name": "SPRING_PROFILES_ACTIVE", "value": "prod"},
                {"name": "AWS_REGION", "value": "$AWS_REGION"},
                {"name": "JAVA_OPTS", "value": "-Xmx768m -XX:MaxRAMPercentage=75.0"}
              ],
              "logConfiguration": {
                "logDriver": "awslogs",
                "options": {
                  "awslogs-group": "$LOG_GROUP",
                  "awslogs-region": "$AWS_REGION",
                  "awslogs-stream-prefix": "ecs"
                }
              },
              "healthCheck": {
                "command": ["CMD-SHELL", "curl -f http://localhost:8081/ || exit 1"],
                "interval": 30,
                "timeout": 10,
                "retries": 5,
                "startPeriod": 90
              }
            }
          ]
        }
        EOF
        
        echo "‚úÖ Task definition created with increased resources"
        cat task-definition.json | jq '.containerDefinitions[0] | {cpu, memory, healthCheck}'

    - name: Register new task definition
      id: register-task-def
      run: |
        echo "üìù Registering new task definition..."
        
        NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
          --cli-input-json file://task-definition.json \
          --query 'taskDefinition.taskDefinitionArn' \
          --output text)
        
        echo "new-task-def-arn=$NEW_TASK_DEF_ARN" >> $GITHUB_OUTPUT
        echo "‚úÖ Registered: $NEW_TASK_DEF_ARN"

    - name: Perform zero-downtime deployment
      run: |
        echo "üöÄ Starting zero-downtime deployment..."
        
        # Get current count
        CURRENT_COUNT=$(aws ecs describe-services \
          --cluster $ECS_CLUSTER \
          --service $ECS_SERVICE \
          --query 'services[0].desiredCount' \
          --output text)
        
        # First, ensure service is stable with current deployment
        echo "üìä Current state: $CURRENT_COUNT tasks desired"
        
        # Update with safe deployment configuration
        aws ecs update-service \
          --cluster $ECS_CLUSTER \
          --service $ECS_SERVICE \
          --task-definition ${{ steps.register-task-def.outputs.new-task-def-arn }} \
          --desired-count $CURRENT_COUNT \
          --health-check-grace-period-seconds 180 \
          --force-new-deployment \
          --deployment-configuration '{
            "deploymentCircuitBreaker": {
              "enable": false,
              "rollback": false
            },
            "maximumPercent": 200,
            "minimumHealthyPercent": 50
          }' \
          --query 'service.serviceName' \
          --output text
        
        echo "‚úÖ Deployment initiated with relaxed health requirements"

    - name: Monitor deployment with enhanced logging
      run: |
        echo "üëÄ Monitoring deployment..."
        
        DEPLOYMENT_COMPLETE=false
        MAX_ATTEMPTS=30
        ATTEMPT=0
        
        while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
          ATTEMPT=$((ATTEMPT + 1))
          
          # Get service info
          SERVICE_INFO=$(aws ecs describe-services \
            --cluster $ECS_CLUSTER \
            --service $ECS_SERVICE \
            --query 'services[0]')
          
          # Extract deployment info
          DEPLOYMENTS=$(echo $SERVICE_INFO | jq -r '.deployments')
          DEPLOYMENT_COUNT=$(echo $DEPLOYMENTS | jq 'length')
          RUNNING_COUNT=$(echo $SERVICE_INFO | jq -r '.runningCount')
          DESIRED_COUNT=$(echo $SERVICE_INFO | jq -r '.desiredCount')
          
          echo "üìä Attempt $ATTEMPT/$MAX_ATTEMPTS - Running: $RUNNING_COUNT/$DESIRED_COUNT, Deployments: $DEPLOYMENT_COUNT"
          
          # Check if deployment is complete
          if [ "$DEPLOYMENT_COUNT" -eq 1 ]; then
            PRIMARY_STATUS=$(echo $DEPLOYMENTS | jq -r '.[0].status')
            PRIMARY_RUNNING=$(echo $DEPLOYMENTS | jq -r '.[0].runningCount')
            PRIMARY_DESIRED=$(echo $DEPLOYMENTS | jq -r '.[0].desiredCount')
            
            if [ "$PRIMARY_STATUS" = "PRIMARY" ] && [ "$PRIMARY_RUNNING" -eq "$PRIMARY_DESIRED" ]; then
              echo "‚úÖ Deployment completed!"
              DEPLOYMENT_COMPLETE=true
              break
            fi
          fi
          
          # Check for stuck deployments
          if [ $ATTEMPT -gt 10 ]; then
            EVENTS=$(aws ecs describe-services \
              --cluster $ECS_CLUSTER \
              --service $ECS_SERVICE \
              --query 'services[0].events[:3]')
            
            echo "üìã Recent events:"
            echo $EVENTS | jq -r '.[] | "  - \(.createdAt): \(.message)"'
            
            # Check for task failures
            FAILED_TASKS=$(aws ecs list-tasks \
              --cluster $ECS_CLUSTER \
              --service-name $ECS_SERVICE \
              --desired-status STOPPED \
              --query 'taskArns[:1]' \
              --output text)
            
            if [ ! -z "$FAILED_TASKS" ]; then
              echo "‚ùå Found failed tasks, checking reasons..."
              aws ecs describe-tasks \
                --cluster $ECS_CLUSTER \
                --tasks $FAILED_TASKS \
                --query 'tasks[0].[stoppedReason,stopCode]' \
                --output text
            fi
          fi
          
          sleep 30
        done
        
        if [ "$DEPLOYMENT_COMPLETE" = false ]; then
          echo "‚ö†Ô∏è Deployment did not complete in expected time"
          echo "üìã Final service state:"
          aws ecs describe-services \
            --cluster $ECS_CLUSTER \
            --service $ECS_SERVICE \
            --query 'services[0].[serviceName,runningCount,desiredCount]' \
            --output table
        fi

    - name: Verify deployment and health
      if: always()
      run: |
        echo "üè• Verifying deployment health..."
        
        # Get running tasks
        RUNNING_TASKS=$(aws ecs list-tasks \
          --cluster $ECS_CLUSTER \
          --service-name $ECS_SERVICE \
          --desired-status RUNNING \
          --query 'taskArns' \
          --output text)
        
        if [ ! -z "$RUNNING_TASKS" ]; then
          echo "‚úÖ Found running tasks"
          
          # Check task details
          aws ecs describe-tasks \
            --cluster $ECS_CLUSTER \
            --tasks $RUNNING_TASKS \
            --query 'tasks[*].[taskArn,lastStatus,healthStatus]' \
            --output table
        else
          echo "‚ùå No running tasks found"
        fi
        
        # Test endpoints
        echo "üß™ Testing endpoints..."
        curl -s -o /dev/null -w "HTTPS Status: %{http_code}\n" https://demos.somdip.dev || true
        curl -s -o /dev/null -w "ALB Status: %{http_code}\n" -H "Host: demos.somdip.dev" http://somdip-dev-alb-856223136.us-east-1.elb.amazonaws.com:8081 || true

    - name: Deployment summary
      if: always()
      run: |
        echo ""
        echo "üìä HR Demo Deployment Summary"
        echo "============================="
        echo "‚úÖ Image: ${{ steps.build-image.outputs.image }}"
        echo "‚úÖ Task Definition: ${{ steps.register-task-def.outputs.new-task-def-arn }}"
        echo ""
        echo "Service Status:"
        aws ecs describe-services \
          --cluster $ECS_CLUSTER \
          --service $ECS_SERVICE \
          --query 'services[0].[serviceName,runningCount,desiredCount,pendingCount]' \
          --output table || true
        echo ""
        echo "üîó Application URL: https://demos.somdip.dev"

    - name: Cleanup
      run: |
        rm -f task-definition.json current-task-def.json
        echo "‚úÖ Cleanup completed"
